
# TCP 协议

## 介绍

TCP 协议（Transmission Control Protocol）位于 IP 层之上，负责提供不同主机之间可靠的数据传输。IP 协议保证数据包的能够正确路由或转发（Packet forwarding），TCP 就是在这个前提下，进一步实现，保证数据包能够完整的在主机之间传输。

TCP 头


## TCP 三次握手（Three-way handshake）

在开始传输数据前，需要进行三次握手的操作，用户建立连接。（Connection establishment）

所谓连接是两个主机间维护一个状态，代表两主机之间，某种数据交互的联系。

TCP 三次握手完成后，两个主机的 TCP 状态会表现为 ESTABLISHED 状态

作用：确立双方的初始 Sequence Number（缩写为ISN：Inital Sequence Number，初始化序列号）

为什么三次：
1、避免历史错误链接。（当发起方发现接收方重复的确认了自己的重复请求，发起方会回复 RST 后，断开这个重复连接）
2、

## connection refuse 在 tcpdump 抓包会有什么表现

在使用 `tcpdump` 抓包分析网络问题时，如果遇到 "connection refused" 的情况，通常意味着你尝试连接的服务没有在目标端口上监听，或者目标主机的防火墙配置拒绝了你的连接请求。在 TCP 层面上，这种情况会表现为一个 TCP 三次握手失败的过程，具体来说，你会看到以下的 TCP 包交换序列：

1. **SYN**：客户端发送一个 SYN 包到服务器，请求建立连接。
2. **RST, ACK**：服务器回应一个 RST (重置) 包加上 ACK 标志，这表示没有进程在监听目标端口，因此连接不能建立。

### wireshark 中的表现

红色的 RST 包

<img width="468" alt="image" src="https://github.com/Mr-YYM/knowledge/assets/31896405/76a048e1-f0bb-4ff2-ace6-97ee3077be18">


### 示例

假设客户端 IP 是 `192.168.1.100`，服务器 IP 是 `192.168.1.101`，客户端尝试连接服务器的 80 端口。如果服务没有在运行或被拒绝连接，使用 `tcpdump` 的输出可能如下所示：

```
192.168.1.100.12345 > 192.168.1.101.80: Flags [S], ...
192.168.1.101.80 > 192.168.1.100.12345: Flags [R.], ...
```

- 第一行表示客户端（192.168.1.100）的端口 12345 发送了一个 SYN 包到服务器（192.168.1.101）的 80 端口，尝试开始 TCP 握手。
- 第二行表示服务器响应了一个带有 RST 和 ACK 标志的包，这意味着连接被拒绝。

### 解读 `tcpdump` 输出

在 `tcpdump` 输出中，你可以通过包的 Flags 来识别这些包：

- **S** 标志代表 SYN，表示开始一个新的连接。
- **R** 标志代表 RST，表示重置连接。
- **.`** 表示 ACK，用于确认收到包。

### 注意

- 如果你没有看到期望的 SYN 或 RST, ACK 包，可能需要检查你的 `tcpdump` 过滤条件，确保没有过滤掉这些交换包。
- "connection refused" 错误通常是由于目标端口没有应用程序监听导致的。检查目标系统上的服务是否运行，以及防火墙和安全组设置是否允许该连接。

通过 `tcpdump` 和理解 TCP 包的标志，你可以深入分析并理解网络连接问题的原因。

## TCP 协议的 “粘包” 问题

TCP 协议是一个基于字节流的协议，他会对用户需要发送的数据（一个个字节）进行拆分后，发送到目标服务器。

这里就有个问题，TCP 协议只是负责保证数据的完整性和有序，但是协议不懂得，用户发送出去的数据本身的边界。所以，开发程序的时候，如果我们是基于 TCP 进行数据传输（没有使用 HTTP 这类有做边界分析的应用层协议），我们就需要采取措施，对数据进行有效的边界处理。否则就会出现 “粘包” 的问题。

例如说，服务器收到了: ABCDEFK 这段数据，实际上，这是两个数据，ABCDEF 和 K。为了防止这个粘包问题，我们可以加入区隔符，比如说 ABCDEF\nK。

粘包问题系由于应用层设计不合理导致，并非 TCP 协议的问题。如果面试中被人问到：「如果使用 TCP 发送多个包，这些包粘在一起无法分开怎么办？」，需要指出这个问题本身就存在缺陷。

> HTTP 协议是使用 \r\n\r\n 来分割来 Header 和 Body，然后通过读 Header 中 Content-length 的长度来判断 Body 要读到那里[1]
>
> 当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了 TCP 协议的缓冲区，如果用户开启了 Nagle 算法，那么 TCP 协议可能不会立刻发送写入的数据，它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。
> Nagle 算法确实能够在数据包较小时提高网络带宽的利用率并减少 TCP 和 IP 协议头带来的额外开销，但是使用该算法也可能会导致应用层协议多次写入的数据被合并或者拆分发送，当接收方从 TCP 协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中，应用层协议可能没有办法对它们进行拆分和重组。


## 参考

1. https://www.kawabangga.com/posts/6295
2. https://draveness.me/whys-the-design-tcp-message-frame/

