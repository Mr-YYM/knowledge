# 计算机基础

## 端序（Endian）

所谓端序，就是字节序，是指数据存储在内存中的顺序。大端序（Big-Endian）是将高位字节放在低地址，而小端序（Little-Endian）则是将低位字节放在低地址。

例如整数：0x12345678

假设从左到右， 分别为低地址到高地址

大端序在内存中的顺序为：12 34 56 78（ 低地址（存储数字位大的部分） ---- 高地址（存储数字位小的部分） ）

小端序在内存中的顺序为：78 56 34 12（ 低地址（存储数字位小的部分） ---- 高地址（存储数字位大的部分） ）

采用什么端序，跟 CPU 架构相关，常见的 x86 和 ARM CPU，都是采用小端序。在网络协议（例如 TCP/IP、UDP、HTTP）中，一般采用大端序。所以在网络编程的过程中，需要注意顺序的转换。

## 线程和进程有什么区别，他们都能利用多核处理器吧

进程和线程都是操作系统中进行资源分配和调度的基本单位，但它们之间有一些基本的区别：

1. 独立性：进程是操作系统资源分配的最小单位，线程是处理器调度（执行）的最小单位。进程可以独立运行，而线程则不能，它必须依赖于进程。

2. 资源：进程拥有自己的独立资源空间，包括内存、文件描述符、PID等，而线程则共享其所在进程的资源。线程之间可以直接读写同一进程中的数据，而进程之间则需要使用特殊的进程间通信（IPC）机制。

3. 上下文切换：进程切换需要较大的开销，保存和恢复更多的内容，而线程上下文切换开销小。线程可以看作轻量级的进程。

4. 生命周期：进程的生命周期要比线程的生命周期长。通常情况下，线程会在进程结束时被销毁。

在多核处理器上，线程和进程都可以实现并行运算。如果一个应用程序包含多个线程，操作系统可以将每个线程分配给不同的处理器核心，从而实现并行计算。同样，多个进程也可以被分配到不同的处理器核心。

然而，多线程和多进程对于利用多核处理器的效率并不相同。由于线程之间的资源共享，多线程程序在处理器核心间切换的开销通常要小于多进程程序。然而，多进程程序的资源隔离性更强，对于复杂的计算任务，可能更易于管理和调试。

需要注意的是，由于Python的全局解释器锁（GIL）的存在，Python的多线程并不能真正地利用多核处理器进行并行计算。在这种情况下，如果需要利用多核处理器，通常会使用多进程，或者使用其他可以并行化的Python库（如Numpy，Scipy等）。

## 进程间通信（IPC）机制

进程间通信(Inter-Process Communication，简称IPC)是指进程间如何进行数据交换的一种机制。由于进程的内存空间是相互隔离的，所以进程间是无法直接共享数据的，需要依靠IPC进行数据交换。常见的IPC机制有以下几种：

1. 管道（Pipe）和命名管道（named pipe）: 管道是一种半双工的通信方式，数据只能单向流动，而命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。

2. 信号（Signal）：信号是一种非常复杂的通信方式，用于通知接收进程某个事件已经发生。

3. 消息队列（Message Queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号承载信息量小，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4. 共享内存（Shared Memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

5. 信号量（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止进程在修改共享资源时被其他进程同时修改。

6. 套接字（Socket）：套接字可以用于不同主机之间的进程通信。

下面是使用Python实现的一个简单的进程间通信例子，使用了内置的`multiprocessing`库的`Pipe`函数创建了一个管道，并通过管道实现了两个进程间的通信：

```python
from multiprocessing import Process, Pipe

def f(conn):
    conn.send([42, None, 'hello'])
    conn.close()

if __name__ == '__main__':
    parent_conn, child_conn = Pipe()
    p = Process(target=f, args=(child_conn,))
    p.start()
    print(parent_conn.recv())   # prints "[42, None, 'hello']"
    p.join()
```
在上述代码中，首先通过`Pipe`函数创建了一个管道，然后创建了一个子进程，并将管道的一端传递给子进程。子进程通过管道发送数据，父进程通过管道接收数据。

由于C语言不像Python那样有现成的并发库，所以在C语言中实现IPC会比较复杂，涉及到许多底层的系统调用。具体实现方式会根据所使用的IPC机制的不同而不同，这里就不详细展开了。

## 有关于字符与二进制

> 我们能看到的这些文本，是不是都有类似于 ASCII或Unicode字符集去对应的 ?

是的，你的理解是正确的。我们看到的文本实际上都是由字符集映射过来的。

字符集（charset）就是一套字符和数字之间的映射表。例如，在最早的ASCII字符集中，字母"A"被映射为数字65，字母"Z"被映射为数字90，等等。这种映射关系使得计算机可以理解和存储人类可读的文本。

然而，ASCII字符集只有128个字符，这不足以表示全世界所有的语言文字。因此，后来又出现了更大的字符集，如Unicode。Unicode被设计成可以表示任何语言的任何字符，所以它有很多的字符和数字的映射关系。

所以，当我们看到一个文本文件时，我们实际上看到的是字符集中的字符映射成的文本，而这些字符在底层被存储为二进制数据。

> 文本有字符集，那图像文件呢，是不是也有类似于字符集的东西，对应某种显示效果

图像文件和文本文件是有一些根本的区别的。文本文件的数据由人类可读的字符组成，这些字符由字符集进行映射。而图像文件的数据由像素（Pixel）组成，这些像素表示图像中的颜色和位置信息。

像素包含一组颜色值，通常是红色（R）、绿色（G）和蓝色（B）的组合，每种颜色在0到255之间有一个值。这就是我们经常听到的RGB颜色模式。一张图片就是一个二维的像素数组，包含了每个像素点的颜色值信息。

这些像素的颜色值以及它们在图像中的位置就定义了图像的显示效果。所以，对于图像文件，它们并没有类似字符集的映射机制，而是通过记录像素信息来存储和显示图像。

此外，图像文件通常还包括一些元数据，例如图像的尺寸、分辨率、颜色模式等信息。这些信息被存储在图像文件的头部，以便正确地解码和显示图像。
